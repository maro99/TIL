# HTTPS는 왜쓰고 SSL은 어떤 역할인지?  

## 당장 내 머리속에 있는 것들(틀린것도 많다):   
기존의 웹의 프로토콜인 HTTP의 보안이 안된다는 단점을 보완하기 위해 만들어 진것이 HTTPS이다. HTTP같은 경우 안의 컨텐츠들을 암호화 해서 보내지 않기 때문에 중간에 패킷을 가로채 서 악용할 소지가 있다. HTTPS를 사용하게 되면 전달되는 패킷이 암호화 되기 때문에 악용할수없다. 이런 암호화는 osi7계층(a penguin said that nobody drinks pepsi)=(application present transport network datalink pysical)에서 SSL(SECURE SOCKET LAYER를 전송계층과,에플리케이션 계층 사이에 위치시켜서 이루어진다.  이 암호화 및 복화화를 중간에서 매니징 해주는 제 3자가 존제하는데(내경우 공짜로 잘 찾아서 했던것 같음) 클라이언트가 브라우저로 서버에 접속시 서버가 미리 제3자에게 등록해놓은 공개키 암호키중 공개키를 유저에게 준다. 그리고 앞으로의 서버와 브라우져 사이의 모든 통신에서 이 키를 가지고 통신의 보안을 보장하게 된다. (이부분정확히 잘 모르겠다.)     해커도 결국에는 이 공개키를 >가질수 있지만 어떤 유저에 대해 서버가 돌려주는 위험한 개인적 정보는 탈취 못하는>듯- 왜냐면 특정유저에 대응되는 공개키로 유저가 서버에 요청 보내고 서버는 그응답>을 해당 공개키로만 복호화 할수 있도록 암호화해서 보낼태니까.)


## 질문.  

### 1.정확히 제 3자가 어떻게 키를 나눠주고 서버는 또 어떻게 그때마다 이 키에 대응되는 다른 키로 브라우저와 암호화복호화를 하는것인지?  
-> 3번 답변 참고.   

### 2.전송계층(tcp)와 어플리케이션 계층 사이에 있는데.. 정확히 이것이 어떤 과정을 거쳐서 프로토콜이 암호화 되는것인지? 왜 계층을 이렇게 쌓듯이 표현한지?   

osi 7 계층모델은 네트워크 구현 설명 위해 각 **프로토콜을 계층별로 분리하여 개발한 모델.**


-> ssl프로토콜은 osi 7계층의 한계층에 속해 동작하는게 아니라 응용,전송계층 사이에서 **독립적인 프로토콜계층 만들어서 동작**    
**전달할때** -> 응용계층의 프로토콜 -> tcp아닌 ssl에 보냄. ssl -> 암호화후 -> tcp로보내 외부인터넷에  전달.<7개층에서 아래로 가는방향>   
**전달 받을때** -> tcp서 받은 데이터 복호화 -> 응용계층 전달.(기존에 tcp, 응용계층http사이 전달하던 방식 그대로 사용. 서로 중간의 ssl을 서로라 인지)    

[새부프로토콜여기참조](https://m.blog.naver.com/xcripts/70122755291) ssl은 이러한 프로토콜이 기존 tcp(전송계층), http(응용계층) 사이에 주고받던 프로토콜 에 적용(osi계층 위아래처럼 프로토콜 비트가 한두개씩 더 붇던지 해서 )   서버 클라 사이에 악수 -> 세션 -> 종료 각단계에서 필요한 정보를 유형별로 주고 받는다.     


### 3.제3자가 존재하는 이유는? 그냥서버가 비밀키 갖고 공개키를 유저에게 나눠주면 안되나?   
-> 제 3자(ca = certificate authority)는 유저 입장에서 존재 해야하만 한다. 왜냐면
해당 사이트가 신뢰할수 있는 사이트인지 즉 ca에서 인정하는 ssl 암호화 복호화 과정을 준수하는 사이트인지 확인해야하기 때문이다.     


**생활코딩 발췌**    
```
1. 통신 내용이 공격자에게 노출되는 것을 막을 수 있다. 
2. 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.
3. 통신 내용의 악의적인 변경을 방지할 수 있다. 
```

**아래 참고 훑어보고 뇌에 남아있는것  적어봄** 
1. 서버 가 ca 에 공개키를 재출   
2.  ca는 전달받은 공개키를 인증서에 담아서 비밀키로 암호화 시킨다  
3. 이제 해당 사이트 접속시 ca가 서버 대신 인증서 제공자에게 발급  
4.  사용자는 자신이 알고있는 신뢰할수있는 ca목록의 ca공개키로 인증서를 복호화  
5. 성공시 ca는 신뢰할수있는 ca   
6.또한 결과로  서버에 대한 공개키 얻는다.(이과정에 실패시 https취소선및 보안문제있다뜬다)  
7.  또한 사용자는 신뢰할만한ca가 보증하는 신뢰할수있는 사이트임을 알게됬고, 이제 복호화한 서버에대한 공개키로 서버와 통신한다.    
8. 초반 서로를 인지하는  ssl헨드쉐이크 후    
9. 대칭키 주고받고 앞으로는 대칭키로 통신함.(대칭키 시스템이 암복호화 더빨라서)     


**참고한것**   
```    
이런 CA 기업이 필요한 이유는 사이트를 제공하는 서버의 공개키가 신뢰할 수 있는 공개키인지를 보장해주기 위해서이다.

How 신뢰 할 수 있는 사이트임을 보장?
1. 사이트 제공자가 CA 인증기관에 공개키를 제출을 하면 CA는 제출 받은 공개키와 사이트에 대한 정보를 인증서에 담아 비밀키로 암호화 한다.

2. CA는 해당 인증서를 사이트 제공자에게 발급해준다.

3. 클라이언트가 사이트에 접속하게 되면 사이트 제공자는 CA로 부터 받은 인증서를 클라이언트에게 준다.

4. 브라우저 내에는 CA 리스트와 공개키가 모두 저장되어져 있다. (브라우저 내에 없는 CA는 인터넷 상에서 신뢰 할 수 없는 증명서이며, 이런 증명서는 브라우저에서 https 프로토콜에 취소선이 그어져 있거나, “이 사이트의 보안 증명서에는 문제가 있습니다.” 같은 메시지가 표시된다.)

5. 클라이언트의 브라우저는 해당 인증서를 읽어 어떤 CA인지를 파악 후, 해당 CA의 공개키로 인증서를 복호화하게 된다. 제대로 복호화가 된다면 해당 인증서는 CA에 의해 암호화된 신뢰 할 수 있는 인증서임을 알 수 있게 된다.

또, 사이트 제공자가 제출한 공개키 또한 인증서 내에 내포되어 있기 때문에 중간에 변조를 할 수 없기 때문에 서버의 공개키를 안전하게 클라이언트에게 제공해준다.

```
## 찾아본것.   

**SSL 헨드세이크 과정**  
```
악수 -> 전송(세션) -> 세션종료   
```
1. **악수** 과정에서는 먼저 어떤 암호화 방식을 서버 클라 사이 쓸건지 정해야한다.   
2. client hello에서 랜덤 문자 + 클라가 쓸 암호화방식 서버에 보낸다.   
3. server hello에서 랜덤문자 전달.(클라가 보낸 암호방식쓰겠다는뜻)  
4. 서버로부터 클라는 인증서 전달받고(위에 서술한것처럼) 유효성 확인    
5. 클라가 가진 신뢰가능한 ca의 공개키로 인증서 복호화 성공시 해당 서버는 신뢰할수있는 사이트 + 해당 서버에 대한 공개키 얻음.    
6.클라는 serverhello, clienthello시 주고 받은 렌덤데이터를 조합해서 premaster키 생성   
7.서버랑 앞으로의 통신에서 이것을 사용하기위해 공유  
8. 헨드 세이크 종류   

9.  **세션**과정에서는 주고받은 premaster키로(session key) 대칭키 방식 암복호화하며 통신.  
10. 데이터 전송 끝나면 ssl통신 끝났음 서로 알리고 대칭키인 세션키 폐기.  





## 참고할만한 사이트   
[몽키](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)    
[생활코딩](https://opentutorials.org/course/228/4894)    
[ssl동작원리](http://iyoon.github.io/jekyll/update/2015/02/22/about_ssl2.html)  
[just doit](https://m.blog.naver.com/xcripts/70122755291)  
